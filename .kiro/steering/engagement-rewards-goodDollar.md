Client-Side Integration
Integrate using the engagement-sdk directly in your dApp
How it works: Your frontend and backend use the EngagementRewards SDK to check eligibility and submit claims directly, without any custom smart contract. The backend signs claims as the app.
Key points:
All reward logic and eligibility checks happen off-chain in your frontend/backend using the SDK.
User signatures are required for first-time registration or after re-applying your app, and are generated in the frontend.
App signatures are generated by your backend using your app's private key.
No custom smart contract is needed; you interact directly with the EngagementRewards contract via the SDK.
Gas fees are still paid by the user for the claim transaction, but all business logic is off-chain.
Best for: Apps without custom on-chain logic, web2-style apps, or when you want to minimize smart contract development.

1. SDK Setup

import { useEngagementRewards,REWARDS_CONTRACT,DEV_REWARDS_CONTRACT } from '@goodsdks/engagement-sdk'

const MyComponent = () => {
const engagementRewards = useEngagementRewards(REWARDS_CONTRACT)

// SDK is ready when hook returns non-null
if (!engagementRewards) return null
} 2. Check Eligibility & Claim

const handleClaim = async () => {
try {
// First check if user can claim
const isEligible = await engagementRewards.canClaim(APP*ADDRESS, userAddress).catch(* => false)
if (!isEligible) {
throw new Error("User not eligible to claim")
}

    // Get current block and prepare signature if needed
    const currentBlock = await engagementRewards.getCurrentBlockNumber()
    const validUntilBlock = currentBlock + 600n // Valid for 600 blocks

    // Generate signature for first-time users or after app re-apply
    let signature = "0x"
    if (!(await engagementRewards.isUserRegistered(APP_ADDRESS, userAddress))) {
      signature = await engagementRewards.signClaim(
        APP_ADDRESS,
        INVITER_ADDRESS,
        validUntilBlock
      )
    }


    // Get app signature from backend
    const appSignature = await getAppSignature({
      user: userAddress,
      validUntilBlock: validUntilBlock.toString(),
      inviter: INVITER_ADDRESS
    })

    // Submit claim
    const receipt = await engagementRewards.nonContractAppClaim(
      APP_ADDRESS,
      INVITER_ADDRESS,
      validUntilBlock,
      userSignature,
      appSignature
    )

} catch (error) {
console.error("Claim failed:", error)
}
} 3. Get App Signature from Backend

// Example of getting app signature from backend
const getAppSignature = async (params: {
user: string,
validUntilBlock: string,
inviter: string
}) => {
try {
const response = await fetch('https://your-backend/api/sign-claim', {
method: 'POST',
headers: {
'Content-Type': 'application/json',
'Authorization': `Bearer ${YOUR_AUTH_TOKEN}`
},
body: JSON.stringify(params)
})

    if (!response.ok) {
      throw new Error('Failed to get app signature')
    }

    const { signature } = await response.json()
    return signature as `0x${string}`

} catch (error) {
console.error('Error getting app signature:', error)
throw new Error('Failed to get app signature')
}
} 4. Backend Implementation Example

// Example Node.js/Express backend endpoint
import { createWalletClient, http, parseEther, createPublicClient } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { celo } from 'viem/chains'
import { EngagementRewardsSDK } from '@goodsdks/engagement-sdk'
import express from 'express'

const router = express.Router()

// App configuration should be in environment variables
const APP_PRIVATE_KEY = process.env.APP_PRIVATE_KEY! as `0x${string}`
const APP_ADDRESS = process.env.APP_ADDRESS! as `0x${string}`
const REWARDS_CONTRACT = process.env.REWARDS_CONTRACT! as `0x${string}`

// Initialize viem clients
const account = privateKeyToAccount(APP_PRIVATE_KEY)
const publicClient = createPublicClient({
chain: celo,
transport: http()
})
const walletClient = createWalletClient({
chain: celo,
transport: http(),
account
})

// Initialize SDK
const engagementRewards = new EngagementRewardsSDK(
publicClient,
walletClient,
REWARDS_CONTRACT
)

router.post('/api/sign-claim', async (req, res) => {
try {
const { user, validUntilBlock, inviter } = req.body
if (!user || !validUntilBlock) {
return res.status(400).json({ error: 'Missing required parameters' })
}

    // Validate user is authorized to request signature
    if (!isAuthorized(req)) {
      return res.status(401).json({ error: 'Unauthorized' })
    }

    // Use SDK to prepare signature data
    const { domain, types, message } = await engagementRewards.prepareAppSignature(
      APP_ADDRESS,
      user as `0x${string}`,
      BigInt(validUntilBlock)
    )

    // Sign the prepared data
    const signature = await walletClient.signTypedData({
      domain,
      types,
      primaryType: 'AppClaim',
      message
    })

    // Log signature request for auditing
    await logSignatureRequest({
      app: APP_ADDRESS,
      user,
      inviter,
      validUntilBlock,
      signature
    })

    return res.json({ signature })

} catch (error) {
console.error('Error signing message:', error)
return res.status(500).json({ error: 'Failed to sign message' })
}
})
// ...existing code...
Security Considerations
Never expose your app's private key in frontend code
Implement proper authentication for signature requests
Add rate limiting to prevent signature request abuse
Validate all user inputs on the backend
Keep logs of all signature requests for auditing
Consider using a dedicated signing service/HSM for production
